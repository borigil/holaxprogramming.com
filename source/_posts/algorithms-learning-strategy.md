---
title: 알고리즘 학습 전략
date: 2017-06-30 11:54:07
categories: fundamentals
---

<img src='https://i1.wp.com/texblog.org/Wordpress/wp-content/uploads/2014/06/big-o-example-latex.png' width='500' />

## 시간 복잡도 

어떤 알고리즘이 얼마나 걸리느냐? CPU 사용량은 얼마인가?
쉽게 정리하면 해당 알고리즘이 데이터 양에 따라서 얼마나 시간이 걸리는지에 대한 표현이라고 보면 된다. 이를 바탕으로 좋은 알고리즘인지 판단이 가능하다.


## 공간 복잡도

어떤 알고리즘이 얼마나 메모리를 차지 하느냐? RAM 사용량은 얼마인가?

> Notice
대게 공간과 시간은 거의 항상 반비례 하는 경향이 있다.


## 시간 복잡도의 표현법

#### Big O 표기법 - O(N)

가장 많이 쓰이는 표현법으로 알고리즘 실행 시간의 상한을 나타낸 표기법 (최악의 효율)

#### 오메가 표기법 

알고리즘 실행 시간의 하한을 나타낸 표기법 (최상의 효율)

#### 세타 표기법

알고리즘 실행 시간의 평균 시간을 나타낸 표기법 (평균)

## Big O 표기법 예시


> 1(상수) 
- 입력되는 데이터양과 상관없이 일정한 실행 시간을 가진다.


> logN 
- 데이터양이 많아져도, 시간이 조금씩 늘어난다.
- 시간에 비례하여, 탐색 가능한 데이터양이 2의 n승이 된다.
- Binary Search


> N
- 데이터양에 따라 시간이 정비례한다.
- 선형 탐색, for 문을 통한 탐색을 생각하면 되겠다.

> N log N
- 데이터양이 N배 많이 진다면, 실행 시간은 N배 보다 조금더 많아 진다. (정비례 하지 않는다. )


> N의 제곱
- 데이터양에 따라 걸리는 시간은 제곱에 비례한다.
- 2중 for 문을 사용하는 버블 정렬, 선택 정렬 등

그렇다면 아래와 같은 알고리즘의 시간복잡도를 Big O 표기법으로 표현하면 ?

```java
public static void bubble(int[] a) {
	for (int i = a.length - 1; i >= 0; i--) {
		boolean flipped = false;
		for (int j = 0; j < i; j++) {
			if(a[j] > a[j + 1]) {
				int T = a[j];
				a[j] = a[j + 1];
				a[j + 1] = T;
				flipped = true;
			}
		}
		if(!flipped)
			break;
	}
}
```

위의 bubble 이라는 Method는 일정하지 않은 정수 배열을 전달 받아 정렬 하는 버블정렬 알고리즘이다. 배열을 탐색 하면서 Swap하는 for문과 인덱스가 증가하면서 다시 탐색하기 때문에 O(N^2) 의 시간복잡도를 가진다.
